# Content 01
- Create a configmap named `lconfig` with values foo=lala,foo2=lolo
    - kubectl create cm lconfig --from-literal=foo=lala --from-literal=foo2=lolo
- Display its values
    - kubectl get cm lconfig -o yaml
- Create and display a configmap from a file (named fconfig). Create the file with `echo -e "foo3=lili\nfoo4=lele" > config.txt`
    - kubectl create cm fconfig --from-file=config.txt
    - kubectl get cm fconfig -o yaml 
- Create and display a configmap from a .env file named econfig. Create the file with the command. `echo -e "var1=val1\n# this is a comment\n\nvar2=val2\n#anothercomment" > config.env`
    - kubectl create cm econfig --from-env-file=config.env
    - kubectl get cm econfig -o yaml

- Create and display a configmap from a file, giving the key 'special'. Create the file with. `echo -e "var3=val3\nvar4=val4" > config4.txt`
    - kubectl create cm special --from-file=special=config4.txt
    - kubectl get cm special -o yaml

- Create a configMap called 'options' with the value var5=val5. Create a new nginx pod that loads the value from variable 'var5' in an env variable called 'option'
    - kubectl create cm options --from-literal=var5=val5
    - `004.yml` kubectl run nginx --image=nginx --dry-run=client -o yaml > 004.yml
    - kubectl apply -f 004.yml
    - kubectl exec nginx -- sh -c 'echo $option'
    - kubectl exec nginx2 -- env | grep var

- Create a configMap 'anotherone' with values 'var6=val6', 'var7=val7'. Load this configMap as env variables into a new nginx pod
    - kubectl create cm anotherone --from-literal=var6=val6 --from-literal=var7=val7
    - kubectl run nginx2 --image=nginx --dry-run -o yaml > 005.yml          
    - vi 005.yml
    - kubectl get pods

- Create a configMap 'cmvolume' with values 'var8=val8', 'var9=val9'. Load this as a volume inside an nginx pod on path '/etc/lala'. Create the pod and 'ls' into the '/etc/lala' directory. 
    - kubectl create cm cmvolume --from-literal=var8=val8 --from-literal=var9=val9
    - `006.yml` kubectl apply -f 006.yml 
    -  kubectl exec nginx3 -- ls /etc/lala

- Create the YAML for an nginx pod that runs with the user ID 101. No need to create the pod
    - `007.yml`

- Create the YAML for an nginx pod that has the capabilities "NET_ADMIN", "SYS_TIME" added to its single container
    - `008.yml`


- Create an nginx pod with requests cpu=100m,memory=256Mi and limits cpu=200m,memory=512Mi
    - `009.yml`

- Create a secret called mysecret with the values password=mypass
    - kubectl create secret generic mysecret --from-literal=password=mypass

- Create a secret called mysecret2 that gets key/value from a file. Create a file called username with the value admin: `echo -n admin > username`
    - kubectl create secret generic mysecret2 --from-file=username
- Get the value of mysecret2
    - kubectl get secret mysecret2 -o yaml 
- Create an nginx pod that mounts the secret mysecret2 in a volume on path /etc/foo
    - `010.yml`
    - kubectl apply -f 010.yml 
    - kubectl exec nginx -- sh -c 'ls /etc/foo'
    - kubectl exec nginx -- sh -c 'cat /etc/foo/username'

- Delete the pod you just created and mount the variable 'username' from secret mysecret2 onto a new nginx pod in env variable called 'USERNAME'
    - kubectl delete pod nginx
    - `011.yml` kubectl apply -f 011.yml *incorrect answer though, be careful in the real exam*
    - kubectl exec nginx -- sh -c 'echo $username'  *incorrect answer though, be careful in the real exam*
    - `011_precise.yml` kubectl apply -f 011_precise.yml
    - kubectl exec nginx -- sh -c 'echo $USERNAME'


- See all the service accounts of the cluster in all namespaces
    - kubectl get sa -A

- Create a new serviceaccount called 'myuser'
    - kubectl create sa myuser
    
- Create an nginx pod that uses 'myuser' as a service account
    - `012.yml` kubectl apply -f 012.yml `WRONG ANSWER, for some reason documentation does not have example :( , check 012_correct.yml`
    - kubectl delete sa myuser
    - kubectl delete nginx

# Content 02


# Content 03
